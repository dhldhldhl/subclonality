---
title: "Part 3 liquidCNA"
author: "Dohun Lee"
date: "01/06/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(pracma); library(ggplot2); library(ggpubr); library(reshape2); 
library(mixtools); library(fitdistrplus); library(dplyr); library(QDNAseq); 
require(gtools); library(gridExtra); library(devtools)
source_url("https://raw.githubusercontent.com/elakatos/liquidCNA/main/mixture_estimation_functions.R")
```

This is a quick R Markdown document going through the steps of liquidCNA pipeline for one patient.

First, we load the outputs of QDNA...

# Load data

```{r load QDNAoutput}
#load parsed metadata
load("bam_by_patient.RData")
p_vec <- 1:length(patient_ids)
p <- p_vec[1]

#load QDNA output of CN dataframe 
seg.df <- read.delim(paste0("2_QDNA_CNout/segment_", patient_ids[p], ".txt"))
cn.df <- read.delim(paste0("2_QDNA_CNout/raw_cn_", patient_ids[p], ".txt"))

#parse dataframe
seg.df <- seg.df[,-(1:4)]
cn.df <- cn.df[,-(1:4)]

colnames(seg.df) <- paste0("Sample", 1:ncol(seg.df))
colnames(cn.df) <- paste0("Sample", 1:ncol(cn.df))

#re-normalise raw and segmented CN values to be centred at CN=2
reNorm <- centreSegs(seg.df)
seg.df <- as.data.frame(t(t(seg.df)/reNorm)*2)
cn.df <- as.data.frame(t(t(cn.df)/reNorm)*2)

```

Then, explore the CN data we have:
```{r exploreCN, echo=TRUE}
head(seg.df)
head(cn.df)
#Plot the CN distribution of each sample to gain a quick overview
ggplot(reshape2::melt(seg.df), aes(x=value,y=..scaled.., colour=variable)) +
  geom_density(adjust=1) +
  theme_bw() + scale_x_continuous(limits=c(0.5, 5)) +
  labs(x='Segment copy number',y='Density',colour='')
```

# Generate ensemble segments

Generate a dataframe of ensemble segments contiguous sections of bins that are constant in ALL samples.

```{r ensemble}
segchange <- sapply(1:(nrow(seg.df)-1),
                    function(i) sum(seg.df[i,]!=seg.df[(i+1),])>0)
seg.data <- data.frame(start=c(1,which(segchange)+1),
                       end=c(which(segchange),length(segchange)+1))
seg.data$length <- seg.data$end - seg.data$start+1
```

Filter out small segments and update their values by fitting a normal distribution to bins in the segment
```{r manipulate_segments}
#Filter segment
seg.sub <- subset(seg.data, length>12) #12 500kb bins
cat('Total number of segments retained: ',nrow(seg.sub))

#Update segment 
seg.fit <- getNormalFitSegments(seg.sub, cn.df)

seg.cns <- seg.fit[[1]]
names(seg.cns) <- names(seg.df)

seg.df.upd <- data.frame(matrix(NA, ncol=ncol(seg.df), nrow=nrow(seg.df)))
names(seg.df.upd) <- names(seg.df); row.names(seg.df.upd) <- row.names(seg.df)

for(i in 1:nrow(seg.sub)){
  seg.df.upd[seg.sub$start[i]:seg.sub$end[i],] <- seg.cns[i,]
}
```

# Purity Estimation
Parameters for purity estimation. **How do we set the first two parameters. Especially the first one, do we have any prior information that can help us set this?**
```{r puritySetPARAM}
w = c(0.3,1,0.8,0.15,0.05) #weights of different CN states
maxCN=8 #assumed maximum CN 
adjVec = c(0.5,0.6,0.8,0.9,1,1.2,1.3,1.5,1.8,2) #smoothing kernel adjustments
pVec = seq(0.05, 0.5, by=0.005) #range of purity values to be evaluated
```

Estimated optimal purity values are those that minimise mean and median. Optimal purities stored in pHat.df.
```{r estimating_optimal_purity }
pHat.df <- data.frame(matrix(vector(),ncol=ncol(seg.df.upd), nrow=2))
names(pHat.df) <- names(seg.df.upd)
row.names(pHat.df) <- c('mean','median')
for(i in 1:ncol(seg.df.upd)){
  x <- na.omit(seg.df.upd[,i])
  pFits <- as.data.frame(sapply(adjVec,
                                function(a) sapply(pVec,
                                                   function(p) evalPurityDensity(p,w,a,x,maxCN))))
  pFits$p <- pVec
  mins <- c(pVec[which.min(apply(pFits[,1:length(adjVec)],1,mean))],
            pVec[which.min(apply(pFits[,1:length(adjVec)],1,median))])
  plF <- ggplot(melt(pFits,id='p'), aes(x=p, y=value)) + geom_point(size=2, alpha=0.3)+
    theme_bw() +
    geom_vline(xintercept = mins, linetype=c('dashed','dotted'), colour=c('red','blue')) +
    labs(title=names(seg.df.upd)[i])
  print(plF)
  pHat.df[,names(seg.df.upd)[i]] <- mins
}
```

```{r estimated_purity, echo = FALSE}
cat('Estimated purity values:\n')
print(pHat.df)
```

## Correct CN values by purity
Correct segment CN values (stored in seg.df.upd and seg.cns) with the computed purities using equation:

* CN_corr = 1/p * (CN-2) + 2

```{r correct_w_purity}
pVec <- as.numeric(pHat.df[1,,drop=T])
seg.df.corr <- as.data.frame(t(t(seg.df.upd-2)*1/pVec)+2)
seg.cns.corr <- as.data.frame(t(t(seg.cns-2)*1/pVec)+2)
```

Optional filtering of samples with low filtering. **Overall, samples in our data seems to have low purity. Would this need extra consideration?**
```{r filter_low_purity}
purity_threshold <- 0
abovePurTh <- pVec >= purity_threshold
seg.df.corr <- seg.df.corr[,abovePurTh]
seg.cns.corr <- seg.cns.corr[,abovePurTh]
```

Plot purity-corrected segment distribution:
```{r  plot_segment_distribution}
ggplot(melt(as.data.frame(seg.df.corr)), aes(x=value, colour=variable)) +
  geom_density(adjust=1) + theme_bw() +
  scale_x_continuous(limits=c(0,8)) + geom_vline(xintercept = 1:6) +
  labs(x='Purity-corrected segment CN',y='Density',colour='')
```

# Derive sample order and subclonal segments
##  Designate reference sample 

Designate reference sample from which deltaCN across samples are calculated. Reference sample selected as "Sample 1" as it is the first sample (date-wise) for every patient.

```{r choose_ref_sample}
baseSample <- 'Sample1'
seg.dcn <- seg.cns.corr - seg.cns.corr[,baseSample]
seg.dcn.nonBase <- seg.dcn %>% select(-one_of(baseSample))
```

## Ordering: Permutation of remaining samples
Choose samples to investigate (all non-base samples by default), then generate all possible permutations
```{r ordering_permutation}
colToUse <- names(seg.dcn.nonBase)

nCol <- length(colToUse)
seg.dcn.toOrder <- seg.dcn.nonBase[,colToUse]
ordVec <- permutations(nCol,nCol,colToUse)
```

Set parameters to be used when evaluating sample order and segment monotony
```{r ordering_parameters}
filterMethod <- 'sd'#exclude clonal, sd < theta
cutOffVec <- seq(0.025,0.5,by=0.005) #cut-off values for pre-filtering
epsilon <- 0.05 #error margin for monotony
```

Diagnostic plot:

* plot1: proportion of subclonal segments
* plot2: total number of non-clonal (light blue) and subclonal (dark blue) segments

A typical cut-off ~0.1 is adequate. Too low or too high cut-off will select for noise. Ideal cut-off should have a reasonable number of subclonal segments (5-20), while maximising the subclonal proportion. We can automate choosing of optimal cut off.

```{r diag_plot}
fitInfo <- list()
for (cutOff in cutOffVec){
  seg.dcn.Eval <- filterSegmentRatios(seg.dcn.toOrder, cutOff, filterMethod, 0)
  best <- findBestOrder(seg.dcn.Eval, ordVec, epsilon, nCol, 0)
  fitInfo[[as.character(cutOff)]] <- best
}

fitInfo.df <- data.frame(cutOff = cutOffVec,
                         maxFit = sapply(fitInfo, function(x) x$max),
                         segsAboveCut = sapply(fitInfo, function(x) length(x$cons)),
                         segsInOrder = sapply(fitInfo, function(x) max(sapply(x$segs, length))))
p1 <- ggplot(fitInfo.df, aes(x=cutOff, y=maxFit)) + geom_line(size=2,colour='darkgreen') + theme_bw() +
  labs(x='Clonal cut-off',y='Subclonal proportion (of non-clonal segments)')
p2 <- ggplot(fitInfo.df, aes(x=cutOff, y=segsAboveCut)) + geom_line(size=2,colour='deepskyblue3') +
  geom_line(aes(y=segsInOrder), size=2,colour='dodgerblue4') + theme_bw() +
  labs(x='Clonal cut-off',y='Total number of non-clonal and subclonal segments')
grid.arrange(p1,p2,nrow=1)
```

```{r opt_cut_off}
minSegmentNumber <- 5
recommendCutOff <- getCutOffAuto(fitInfo.df, minSegmentNumber)
cat('Recommended cut-off is: ', recommendCutOff)
```

plot DeltaCN for chosen cut off + ordering + segment classification:
```{r deltaCN_across_order_plot}
cutOff <- recommendCutOff
fit <- fitInfo[[as.character(cutOff)]]

for (ind in 1:nrow(fit$ord)){
  seg.plot <- seg.dcn[,rev(c(fit$ord[ind,],baseSample))]
  seg.plot$id <- row.names(seg.plot)
  seg.plot$filtered <- seg.plot$id %in% fit$cons
  seg.plot$order <- seg.plot$id %in% fit$segs[[ind]]
  
  p <- ggplot(melt(seg.plot, id=c('id','filtered','order')), aes(x=variable, y=value, group=id, colour=paste0(filtered,' | ',order))) +
    geom_line(size=1.2, alpha=0.75) + theme_bw() +
    scale_colour_manual(values=c('grey70','#487a8b','firebrick3'), labels=c('clonal','unstable','subclonal')) +
    labs(x='',y='Change in segment CN (DeltaCN)',colour='Segment type')
  print(p)
}
```

if more than one sample order exists:
```{r more_than_one_order}
ordInd <- 1
seg.dcn.toUse <- seg.dcn[fit$segs[[ordInd]],rev(fit$ord[ordInd,])]
```

# Derive Subclonal Ratio

RELATIVE subclonal-ratio is estimated by segment-by-segment comparison to the highest subclonal-ratio sample
```{r calc_relative_subclone_ratio}
topSample <- names(seg.dcn.toUse)[ncol(seg.dcn.toUse)]
toEstimate <- setdiff(names(seg.dcn.toUse), c(topSample,baseSample))

final.ratios <- estimateRSegmentRatio(seg.dcn.toUse, toEstimate, topSample, 1)

final.medians <- aggregate(final.ratios$value, 
                           by=list(final.ratios$variable), median)

```

PLOT estimated relative ratios
```{r plot_relative_subclone_ratios}
final.medians$xpos <- 1:nrow(final.medians)

ggplot(final.ratios, aes(y=value, x=variable, weight=1)) + geom_violin(fill='firebrick3',alpha=0.2) +
  theme_bw() + scale_y_continuous(limits=c(0,1.2)) +
  geom_jitter(width=0.1, height=0, colour='firebrick3', size=2, alpha=0.6) +
  #geom_point(data=true.df, aes(x=V3, y=V2), colour='firebrick3', size=3) +
  geom_segment(data=final.medians,aes(x=xpos-0.15,xend=xpos+0.15,y=x,yend=x), size=1.5) +
  labs(x='',y=paste0('Subclonal-ratio compared to ',topSample))
```

Package this into final results table of median relative ratio values.
```{r generate_final_results}
final.results <- aggregate(final.ratios$value, by=list(final.ratios$variable), median)
names(final.results) <- c('time','relratio')
final.results$time <- as.character(final.results$time)
final.results[nrow(final.results)+1,] <- c(topSample, 1)

```

```{r out_final_results}
final.results[nrow(final.results)+1,] <- c(baseSample, 0,0,0)
final.results$purity_mean <- as.numeric(pHat.df[1,match(final.results$time, 
                                                        names(pHat.df))])
final.results$purity_median <- as.numeric(pHat.df[2,match(final.results$time, 
                                                          names(pHat.df))])

cat('Final result table:\n'); print(final.results)
```
